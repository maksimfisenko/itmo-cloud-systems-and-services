# Лабораторная работа #3. Kubernetes

## Введение

Цель данной работы состоит в том, чтобы поднять локально кластер Kubernetes. Однако перед тем, как поднимать этот самый кластер, необходимо разобраться, что из себя в принципе представляет этот самый Kubernetes.

### Что такое Kubernetes?

Если говорить кратко, то **Kubernetes** - программное обеспечение, позволяющее автоматически управлять контейнеризированными приложениями и заметно облегчающее работу с ними.

Kubernetes пользуется огромное количество компаний и разработчиков по всему миру, ведь при работе с контейнерами он обладает следующими преимуществами:
- Легкое и автоматическое масштабирование
- Управление развертыванием приложения
- Обеспечение стабильной работы приложения *(восстановление и т. д.)*
- Балансировка нагрузки
- и так далее

Таким образом, в наше время Kubernetes является практически неотъемлемой частью процесса разработки, развертывания и эксплуатации программного продукта.

В ходе выполнения данной лабораторной работы было необходимо поднять *кластер Kubernetes*, то есть группу серверов, которые вместе управляют контейнерами.

В качестве инструмента для запуска локального кластера на устройстве был выбран **minikube**. minikube обладает большим количеством достоинств по сравнению с другими инструментами, такими как простота использования, поддержка различных дополнений и гибкость настроек, однако для выполнения данной лабораторной работы он был выбран именно засчет первого.

## Ход выполнения

### Установка minikube

В первую очередь minikube надо было установить на устройство. В этом может помочь [инструкция с официального сайта Kubernetes](https://kubernetes.io/ru/docs/tasks/tools/install-minikube/).

Перед установкой было необходимо проверить, поддерживается ли на устройстве виртуализация. Для этого в Windows Terminal была вбита команда `systeminfo`, после чего в ответе была получена в том числе и следующая строчка:

```
Hyper-V Requirements: A hypervisor has been detected. Features required for Hyper-V will not be displayed.
```

Данная строка означается, что на устройстве поддерживается виртуализация, а также уже установлен гипервизор, то есть перед установкой minikube ничего устанавливать дополнительно не надо. Радуемся этому и идем дальше.

#### Установка kubectl

Перед непосредственной установкой minikube необходимо было установить kubectl - инструмент командной строки для работы с Kubernetes. Сделать это можно разными способами, воспользовавшись [инструкцией с официального сайта](https://kubernetes.io/ru/docs/tasks/tools/install-kubectl/#%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-kubectl-%D0%B2-windows). После установки, вбив в командную строку ```kubectl version --client```, убеждаемся в наличии kubectl на устройстве:

```zsh
Client Version: v1.31.1
Kustomize Version: v5.4.2
```

#### И наконец сам minikube

Наконец, устанавливаем сам minikube. Это можно сделать несколькими способами, для меня самым удобным оказался способ установки с помощью исполняемого файла. Думаю, показывать, как я это делал, тут явно будет лишним.

#### Проверка установки

На прошлом шаге minikube был установлен, на данном же этапе необходимо проверить, успешно ли. Для этого запустим локальный кластер minikube на устройстве, вбив в консоль ```minikube start --vm-driver=hyperv```, где hyperv - имя установленного на устройстве гипервизора.

(Ждём много минут...)

Кажется, что minikube заработал. Чтобы убедиться в этом, вбиваем в консоль команду ```minikube status``` и получаем ответ:

```zsh
minikube
type: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured
```

Отлично! Данный ответ говорит нам о том, что minikube установлен и успешно запускается с выбранным гипервизором.


### Создание приложения

Затем было необходимо создать само приложение. Так как целью данной лабораторной работы является поднятие кластера Kubernetes, а не создание приложения, был создан простейший веб-сервер на Go, весь код которого содержится в файле ```main.go```.

```go
package main

import (
	"fmt"
	"net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello, World!")
}

func main() {
	http.HandleFunc("/", handler)
	http.ListenAndServe(":9999", nil)
}
```
Думаю, глядя на код, любой сможет с уверенностью сказать, что делает это приложение - оно запускат веб-сервер на порту 9999. Воспользуемся утилитой **curl** в командной строке: после ввода команды ```curl localhost:9999``` получаем в ответ наш заветный ```Hello, World!```.

### Собираем Docker-образ

На следующем этапе необходимо собрать Docker-образ приложения и поместить его в локальное хранилище minikube.

#### Написание Dockerfile

Первым делом создаём Dockerfile:
```dockerfile
# Используем базовый легковесный образ
FROM golang:1.20-alpine  

# Рабочая директория внутри контейнера
WORKDIR /app

# Копирование исходного кода приложения
COPY . .

# Создание бинарного файла
RUN go build -o main .

# Запуск веб-сервера
CMD ["/app/main"]

# Слушаем порт, использующийся в приложении
EXPOSE 9999
```

#### Создаем образ и проверяем

Ну и собираем наш Docker-образ с помощью команды ```docker build -t app-go .```, получая в ответ строчку ```[+] Building 8.3s (9/9) FINISHED```, что говорит о том, что docker-образ был создан успешно.

На всякий случай проверяем, введя в консоль ```docker images```:
```zsh
REPOSITORY   TAG                IMAGE ID       CREATED              SIZE
app-go       latest             ea49148bf580   About a minute ago   323MB
postgres     16.3               cff6b68a194a   5 months ago         432MB
sonarqube    10.5.1-community   b728f044f72f   5 months ago         787MB
```

Видим на второй строке наш docker-образ. Ура, кажется, мы всё сделали правильно, идём дальше.

### Создание yaml-файлов

Далее нам необходимо создать yaml-файлы (манифесты). 

#### deployment.yaml

Первым создадим yaml-файлов для деплоя нашего приложения:

```yaml
apiVersion: apps/v1 # Версия API
kind: Deployment # Указываем объект типа Deployment
metadata:
  name: app-deployment # Имя деплоймента
spec:
  replicas: 2 # Количество подов для развертывания
  selector:
    matchLabels:
      app: app
  template:
    metadata:
      labels:
        app: app
    spec:
      containers:
      - name: app-container # Имя контейнера
        image: app-go # Используемый docker-образ
        imagePullPolicy: Never # ВОТ БЕЗ ЭТОЙ СТРОЧКИ НЕ РАБОТАЛО НИЧЕГО
        ports:
        - containerPort: 9999 # Открываем порт 9999 в контейнере
```

Хочется обратить внимание на строчку ```imagePullPolicy: Never```, без которой ничего не хотело запускаться. Она нужна для того, чтобы minikube искал Docker-образ именно на локальном устройстве.

#### service.yaml

Также создадим service-файл, нужный для того, чтобы открыть доступ к приложению:

```yaml
apiVersion: v1 # Версия API
kind: Service # Указываем объект типа Service
metadata:
  name: app-service # Имя сервиса
spec:
  type: NodePort # Тип сервиса
  selector:
    app: app
  ports:
    - protocol: TCP # Используем протокол TCP для передачи данных
      port: 80
      targetPort: 9999 # Внутренний порт
      nodePort: 30000 # Внешний порт
```

Наконец, применяем данные ресурсы, используя команду ```kubectl apply -f deployment.yaml -f service.yaml```. После этого всё уже должно работать, можно проверять работу.

### Проверка работоспособности

Чтобы открыть страницу в браузере, можно воспользоваться командой ```minikube service app-service```, которая вывыдет в консоль информацию о нашем работающем сервисе:
```
|-----------|-------------|-------------|---------------------------|
| NAMESPACE |    NAME     | TARGET PORT |            URL            |
|-----------|-------------|-------------|---------------------------|
| default   | app-service |          80 | http://192.168.49.2:30000 |
|-----------|-------------|-------------|---------------------------|
* Starting tunnel for service app-service.
|-----------|-------------|-------------|------------------------|
| NAMESPACE |    NAME     | TARGET PORT |          URL           |
|-----------|-------------|-------------|------------------------|
| default   | app-service |             | http://127.0.0.1:51850 |
|-----------|-------------|-------------|------------------------|
```

Мы видим, что minikube запускает сервис на своём ip *(192.168.49.2)*, используя порт, который был прописан в манифесте *(30000)*. При этом для удобства minikube сразу же создаёт "тунель", чтобы мы могли воспользоваться сервисом на нашем устройстве. Переходим по второму адресу *(127.0.0.1:51850)* и видим нашу "замечательную" страницу:

![Открытая страницу](img_1.png)

> **Ура! В ходе выполнения лабораторной работы получилось поднять на устройстве кластер Kubernetes.**

**Часть со \*:** *to be continued*



