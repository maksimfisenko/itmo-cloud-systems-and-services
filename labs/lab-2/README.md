# Лабораторная 2
## Основное задание 
В этом задание предстояло составить 2 докерфайла. В одном из них требовалось допустить распостранённые ошибки, а во втором исправить их. Для примера я взял простейший пример докера, который поднимает HTTP сервер на порту 8081.
### Плохой докер 
~~~Dockerfile
FROM ubuntu:latest
RUN apt-get update
RUN apt-get install python3
ADD ./static .
EXPOSE 8081
CMD ["python3", "-m", "http.server", "8081"]
~~~
Разберём ошибки из этого файла
#### 1. Latest образы
Любой докер файл начинает с основного образа (FROM ....). Такие образы находяться в специальных репозиториях и импортируются в новый докерфайл при сборке. Репозитории с образами регулярно обновляются, поэтому существуют атрибут latest, который позволяет при каждой сборке образа подтягивать самую последнию версию, без необходимости править докерфайл рукуми. Однако, когда мы создаём контейнер, мы держим в голове конкретную версию того или иного образа, и не знаем как этот образ может в будущем измениться. Поэтому использование последних версий образом, вынуждает следить за каждым обновлением и проверять, что наш код работает стабильно на новых версиях. Чтобы избежать этой работы и потенциальных неопределённостей за хорошую практику принято указывать конкретную версию нужного образа и работать, отталкиваясь от этой версии. При необходимости обновиться, это всегда можно сделать вручную 
#### 2. Избыточные образы
Сразу две ошибки в первой строчке! При создании докерфайла часто хочеться импортировать самый обширный образ из возможных, чтобы не задумываться о доступности тех илил иных функций или команд. Однако сстоит понимать, что импортирвание тяжёлого образа, как в примере, не обходиться бесплатно и негативно сказыается на производительности. Поэтолучше всего при выборе основного образа исходить из принципа достаточности. В примере выше используется только Питон, поэтому достаточно взять только его образ.
#### 3. Обновление репозитория 
Запускать обновления репозитория следует в одной и той же команде RUN что и установка пакетов. Это обусловленно особенностью кеширование в контейнирах, из-за которой за хорошую практику принято мниимизировать количество RUN. Поэтому правильнее было бы написать:
~~~Dockerfile
RUN apt-get update && \
  apt-get -y install python3
~~~
А ещё, как я выяснил уже при сборке, важно не забыть при установки проставить флаг -y, иначе сборка образа сломается на первом же диалоговом окне, где нужны выбрать yes|no
#### 4. Работа в корневой директории
За хорошую практику принято всегда указывать рабочую директорию в докерфайлах и давать им говорящие названия. В больших докефайлах это упрощает понимание смысла выполняемых команд. Также считается, что работа в корневой директории является менее безопасной.
#### 5. ADD vs COPY
Комада ADD включает в себя дополнительыне процессы, помимо копирования файлов в контейнер. Если не знаешь об этих процессах, то они скорее всего и не нужны в текущем контейнере, и лучше по умолчанию для коприрования использовать COPY. Прибегать к ADD рекомендуется только в случае явной необходимости.
Но даже плохой докер  можно собрать:
```zsh
docker build -t bad_docker .
```
А вот чтобы запустить, нужно не забыть проставить соответствие между портами (или как я забыть и потратить пол часа на выяснения почему докер не хочет работать)
```zsh
docker run -d -p 8081:8081 --name bad_docker bad_docker
```
<img width="1904" alt="image" src="https://github.com/user-attachments/assets/6438301a-0e4e-43a5-af8f-8aea010179b8">

### Хороший докер 
Итого, в предыдущем задании ошибок было почти столько же сколько строчек кода. Надо это исправлять! Для этого я составил исправленный докерфайл 
~~~Dockerfile
FROM python:3.11
WORKDIR /var/www/html
COPY ./static .
EXPOSE 8081
CMD ["python3", "-m", "http.server", "8081"]
~~~
Здесь исправлены недочёты, описанные выше.
Для создания контейнера достаточно указать название и директорию (я выполнял команду прямо в директорию с докерфайлом, поэтому достаточно .)
```zsh
docker build -t good_docker .
```
А при запуске не забыть связать порты контейнера и компьютера
```zsh
docker run -d -p 8081:8081 --name good_docker good_docker
```
<img width="1904" alt="image" src="https://github.com/user-attachments/assets/d8cba46a-5b6d-44a4-b1f2-5af259c97818">

### Ошибки при работе с контейнерами 
Даже самый правильный на свете докерфайл не спасает от расспостранённый ошибках при работе с контейнерами. Разберём их отдельно:
Докеры имеют свойство неконтролируемо разрастаться и потреблять всё больше ресурсов. Поэтому важно не забывать **ограничивать потребление** ресурсов отедльным контейнером, чтобы предотвратить черезмерное использваоние вычислительных ресурсов. \
Любой контейнер может быть удалён в любой момент времени. Поэтому ни в коем случае **нельзя хранить данные внутри контейнера**, если их необходимо сохранять.\
Использовать **общий докерфайл для нескольких процессов** также не следует. Если проблема будет с одним из процессов, остановить и заново запустить придётся все прцоессы, что не рационально. Для контейниризации множества зависимых друг от друга процессов лучше подойдёт docker-compose.

## Звёздочка
В этом задании нужно было прделать похожие операция, но теперь вместо Dockefile используется docker-compose, который позволяет создать сразу несколько контейнеров в одном. docker-compose предназначен для работы с более сложными приложениями, поэтому для примера я взял свой недавний проект, где я как раз столкнулся с ипользованием docker-compose
https://github.com/Gosyaa/php_rest_Docker/tree/main
### Плохой docker-compose 
Одним из вариантом docker-compose, который может собрать  данный проект является: 
```yml
version: '3.9'
name: 'php_rest'
services:
  php-env:
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - ./src:/var/www/html
    ports:
      - 8081:80
  mysql_db:
    image: mysql:latest
    command: --default-authentication-plugin=mysql_native_password
    restart: always
    environment:
      MYSQL_DATABASE:  notes_db_vk
      MYSQL_PASSWORD: null
      MYSQL_ALLOW_EMPTY_PASSWORD: true
      MYSQL_ROOT_HOST: '%'

  phpmyadmin:
    image: phpmyadmin:latest
    restart: always
    ports:
      - 9000:80
    environment:
      PMA_ARBITRARY: 1
```
Разберём ошибки отсюда
#### Снова используется latest
Тут всё аналогично DockerFile: в image лучше использовать конкретные версии, а не ссылку на последнюю 
#### Не указаны зависимости контейнеров 
В нашем примере, среда phpmyadmin и php-env не имеют смысла, если не будет работать mysql_db. Такие зависимости следут явно указывать в файле
#### Отстутвует явная ссылка на localhost
Из соображений безопасности рекомендуется связывать порты контейнера с портами локалхоста то есть ```127.0.0.1:8081:80```, вместо 0.0.0.0, который использовался бы по умолчанию и позволял бы получить доступ к приложению в обход прокси
#### Изоляция сетей
В хороший докер также была добавлена изоляция сетей (среда администрирования была отделена от приложения). По умолчанию каждый контейнер находится в общей сети и может общаться с другими контейнерами. В случае, когда в ээтом нет явной необходимости лучше закрыть такую возможность.
### Хороши docker-compose
Итак, учитывая все замеания был составлен новый файл docker-compose
```yml
version: '3.9'
name: 'php_rest'
services:
  php-env:
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - ./src:/var/www/html
    ports:
      - 8081:80
    depends_on:
      - mysql_db
    networks:
      - service
  mysql_db:
    image: mysql:5.7.32
    command: --default-authentication-plugin=mysql_native_password
    restart: always
    environment:
      MYSQL_DATABASE:  notes_db_vk
      MYSQL_PASSWORD: null
      MYSQL_ALLOW_EMPTY_PASSWORD: true
      MYSQL_ROOT_HOST: '%'
    networks:
      - service
      - db

  phpmyadmin:
    image: phpmyadmin:5.2.1
    restart: always
    ports:
      - 9000:80
    environment:
      PMA_ARBITRARY: 1
    depends_on:
      - mysql_db
    networks:
      - db

networks:
  service:
  db:
```
Оба этих файла можно собрать с помощью единственной команды
```bash
docker-compose up --build
```
## Вывод
В этой работе я научился работать с Dockerfile и docker-compose, а также научился отличать хорошие докер файлы от плохих
