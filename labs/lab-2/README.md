# Лабораторная 2
## Основное задание 
В этом задание предстояло составить 2 докерфайла. В одном из них требовалось допустить распостранённые ошибки, а во втором исправить их. Для примера я взял простейший пример докера, который поднимает HTTP сервер на порту 8081.
### Плохой докер 
~~~Dockerfile
FROM ubuntu:latest
RUN apt-get update
RUN apt-get install python3
ADD ./static .
EXPOSE 8081
CMD ["python3", "-m", "http.server", "8081"]
~~~
Разберём ошибки из этого файла
#### 1. Latest образы
Любой докер файл начинает с основного образа (FROM ....). Такие образы находяться в специальных репозиториях и импортируются в новый докерфайл при сборке. Репозитории с образами регулярно обновляются, поэтому существуют атрибут latest, который позволяет при каждой сборке образа подтягивать самую последнию версию, без необходимости править докерфайл рукуми. Однако, когда мы создаём контейнер, мы держим в голове конкретную версию того или иного образа, и не знаем как этот образ может в будущем измениться. Поэтому использование последних версий образом, вынуждает следить за каждым обновлением и проверять, что наш код работает стабильно на новых версиях. Чтобы избежать этой работы и потенциальных неопределённостей за хорошую практику принято указывать конкретную версию нужного образа и работать, отталкиваясь от этой версии. При необходимости обновиться, это всегда можно сделать вручную 
#### 2. Избыточные образы
Сразу две ошибки в первой строчке! При создании докерфайла часто хочеться импортировать самый обширный образ из возможных, чтобы не задумываться о доступности тех илил иных функций или команд. Однако сстоит понимать, что импортирвание тяжёлого образа, как в примере, не обходиться бесплатно и негативно сказыается на производительности. Поэтолучше всего при выборе основного образа исходить из принципа достаточности. В примере выше используется только Питон, поэтому достаточно взять только его образ.
#### 3. Обновление репозитория 
Запускать обновления репозитория следует в одной и той же команде RUN что и установка пакетов. Это обусловленно особенностью кеширование в контейнирах, из-за которой за хорошую практику принято мниимизировать количество RUN. Поэтому правильнее было бы написать:
~~~Dockerfile
RUN apt-get update && \
  apt-get -y install python3
~~~
А ещё, как я выяснил уже при сборке, важно не забыть при установки проставить флаг -y, иначе сборка образа сломается на первом же диалоговом окне, где нужны выбрать yes|no
#### 4. Работа в корневой директории
За хорошую практику принято всегда указывать рабочую директорию в докерфайлах и давать им говорящие названия. В больших докефайлах это упрощает понимание смысла выполняемых команд. Также считается, что работа в корневой директории является менее безопасной.
#### 5. ADD vs COPY
Комада ADD включает в себя дополнительыне процессы, помимо копирования файлов в контейнер. Если не знаешь об этих процессах, то они скорее всего и не нужны в текущем контейнере, и лучше по умолчанию для коприрования использовать COPY. Прибегать к ADD рекомендуется только в случае явной необходимости.
Но даже плохой докер  можно собрать:
```zsh
docker build -t bad_docker .
```
А вот чтобы запустить, нужно не забыть проставить соответствие между портами (или как я забыть и потратить пол часа на выяснения почему докер не хочет работать)
```zsh
docker run -d -p 8081:8081 --name bad_docker bad_docker
```
<img width="1904" alt="image" src="https://github.com/user-attachments/assets/6438301a-0e4e-43a5-af8f-8aea010179b8">

### Хороший докер 
Итого, в предыдущем задании ошибок было почти столько же сколько строчек кода. Надо это исправлять! Для этого я составил исправленный докерфайл 
~~~Dockerfile
FROM python:3.11
WORKDIR /var/www/html
COPY ./static .
EXPOSE 8081
CMD ["python3", "-m", "http.server", "8081"]
~~~
Здесь исправлены недочёты, описанные выше.
Для создания контейнера достаточно указать название и директорию (я выполнял команду прямо в директорию с докерфайлом, поэтому достаточно .)
```zsh
docker build -t good_docker .
```
А при запуске не забыть связать порты контейнера и компьютера
```zsh
docker run -d -p 8081:8081 --name good_docker good_docker
```
<img width="1904" alt="image" src="https://github.com/user-attachments/assets/d8cba46a-5b6d-44a4-b1f2-5af259c97818">

### Ошибки при работе с контейнерами 
Даже самый правильный на свете докерфайл не спасает от расспостранённый ошибках при работе с контейнерами. Разберём их отдельно:
Докеры имеют свойство неконтролируемо разрастаться и потреблять всё больше ресурсов. Поэтому важно не забывать **ограничивать потребление** ресурсов отедльным контейнером, чтобы предотвратить черезмерное использваоние вычислительных ресурсов. 
Любой контейнер может быть удалён в любой момент времени. Поэтому ни в коем случае **нельзя хранить данные внутри контейнера**, если их необходимо сохранять.
Использовать **общий докерфайл для нескольких процессов** также не следует. Если проблема будет с одним из процессов, остановить и заново запустить придётся все прцоессы, что не рационально. Для контейниризации множества зависимых друг от друга процессов лучше подойдёт docker-compose. 
